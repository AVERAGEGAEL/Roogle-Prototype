<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <style>
    /* Basic full-viewport layout */
    html,body { height:100%; margin:0; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#fff; }
    /* Overlay */
    #loadingOverlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.96);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
    }
    #overlayCard {
      width: min(820px, 92%);
      text-align:center;
      background: #fff;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 8px 28px rgba(0,0,0,0.08);
      position: relative;
    }
    #closeBtn {
      position: absolute;
      right: 12px;
      top: 12px;
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      color: #555;
    }
    #closeBtn:hover { color: #111; }
    #loadingSpinner {
      width: 72px; height: 72px; border-radius: 999px;
      border: 8px solid #f0f2f5; border-top-color: #2b7cff;
      animation: spin 900ms linear infinite;
      margin: 14px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loadingMessage { font-size:18px; color:#222; margin-bottom:6px; }
    #loadingSub { color:#666; font-size:13px; margin-bottom:10px; max-width:88%; margin-left:auto; margin-right:auto; }
    #dismissBtn {
      margin-top:14px;
      background:#d9534f;
      color:white;
      padding:8px 14px;
      border-radius:6px;
      border: none;
      cursor: pointer;
    }
    #dismissBtn:hover { background:#c43a3a; }

    /* hidden debug area (kept for message storage but not shown) */
    #debugLogs { display:none; }

    /* iframe fills background under overlay */
    #proxyIframe {
      position: absolute;
      inset: 0;
      width:100%;
      height:100%;
      border: none;
      z-index: 0;
    }

    /* small responsive tweaks */
    @media (max-width:480px) {
      #overlayCard { padding: 18px; }
      #loadingMessage { font-size:16px; }
    }
  </style>
</head>
<body>
  <!-- overlay UI -->
  <div id="loadingOverlay" aria-hidden="false">
    <div id="overlayCard" role="dialog" aria-label="Loading proxy">
      <button id="closeBtn" title="Close overlay" aria-label="Close overlay">‚úï</button>
      <div id="loadingSpinner" aria-hidden="true"></div>
      <div id="loadingMessage">üîÑ Loading site... (0s)</div>
      <div id="loadingSub">Contacting proxy and preparing the page. This overlays until the site is ready or an error occurs.</div>
      <button id="dismissBtn">‚ùå Dismiss</button>
    </div>
  </div>

  <!-- proxied page -->
  <iframe id="proxyIframe" sandbox="allow-scripts allow-forms allow-same-origin allow-popups"></iframe>

  <!-- small hidden debug box (not shown in iframe) -->
  <div id="debugLogs" aria-hidden="true"></div>

  <script>
    // Elements
    const overlay = document.getElementById('loadingOverlay');
    const msg = document.getElementById('loadingMessage');
    const sub = document.getElementById('loadingSub');
    const closeBtn = document.getElementById('closeBtn');
    const dismissBtn = document.getElementById('dismissBtn');
    const iframe = document.getElementById('proxyIframe');
    const hiddenDebug = document.getElementById('debugLogs');

    // Timer
    let elapsed = 0;
    let timer = null;
    function startTimer() {
      stopTimer();
      elapsed = 0;
      msg.textContent = `üîÑ Loading site... (${elapsed}s)`;
      timer = setInterval(() => {
        elapsed++;
        msg.textContent = `üîÑ Loading site... (${elapsed}s)`;
        // show a gentle warning after 30s
        if (elapsed === 30) sub.textContent = "‚è≥ This is taking longer than usual. You can dismiss or try another worker.";
      }, 1000);
    }
    function stopTimer(){
      if (timer) { clearInterval(timer); timer = null; }
    }

    // Hide overlay (and notify parent index if present)
    function hideOverlay(details = {}) {
      overlay.style.display = 'none';
      stopTimer();
      // forward hide message to parent (index.html) so it can also update debug area
      try { parent.postMessage({ type: 'hideLoading', details }, '*'); } catch(e){}
    }

    // Send debug messages to parent (index)
    function forwardDebug(text, level='info') {
      try { parent.postMessage({ type:'debugLog', message: text, level }, '*'); } catch(e){}
      // also keep a local hidden copy
      const p = document.createElement('div');
      p.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
      hiddenDebug.appendChild(p);
      hiddenDebug.scrollTop = hiddenDebug.scrollHeight;
    }

    // Close handlers
    closeBtn.addEventListener('click', () => hideOverlay({manual: true}));
    dismissBtn.addEventListener('click', () => hideOverlay({manual: true}));

    // Listen for client-proxy.js signals (hideLoading)
    window.addEventListener('message', (ev) => {
      const d = ev.data || {};
      if (d?.type === 'hideLoading') {
        forwardDebug('Received hideLoading postMessage from proxy script');
        hideOverlay({source:'postMessage'});
      } else if (d?.type === 'debugLog') {
        // keep local copy and forward to parent ‚Äî helpful when client-proxy posts debug into iframe's DOM
        forwardDebug(`(proxy) ${d.message}`, d.level || 'info');
      } else if (d?.type === 'proxyError') {
        // structured proxy error from client-proxy.js
        forwardDebug(`Proxy Error: ${d.message}`, 'error');
        sub.textContent = d.message || 'Proxy reported an error';
        // hide overlay so user can interact with iframe fallback content
        hideOverlay({error:d.message});
      }
    });

    // scan the iframe content for problematic / duplicate debug markup or 429 pages
    function scanIframeForProblems() {
      let doc;
      try { doc = iframe.contentDocument; } catch (e) { return; }
      if (!doc) return;

      // 1) Remove any element with id/class debugLogs ‚Äî prevents double-UI inside proxied page
      const dup = doc.querySelectorAll('#debugLogs, .debug-logs, .proxy-debug');
      dup.forEach(el => {
        forwardDebug('Removed duplicate debug panel from proxied page');
        el.remove();
      });

      // 2) Detect Cloudflare 429 / "Worker received 429" text and report
      const bodyText = (doc.body && doc.body.innerText) ? doc.body.innerText : '';
      if (bodyText && /worker received\s*429/i.test(bodyText) || /rate-limit|too many requests|429/i.test(bodyText)) {
        // capture a short snippet
        const snippet = bodyText.trim().split('\n').slice(0,6).join(' | ').slice(0,600);
        forwardDebug('Detected rate-limit / 429 response in proxied page: ' + snippet, 'warn');
        sub.textContent = '‚ö†Ô∏è Backend returned rate limit (429). Try switching workers or wait a moment.';
        // hide overlay so user can dismiss and view message
        hideOverlay({error:'429 detected', snippet});
        return;
      }

      // 3) Detect injected script-errors displayed in page (common fallback messages)
      if (bodyText && /(refused to connect|cannot load|blocked by CORS|captcha|recaptcha)/i.test(bodyText)) {
        const snippet = bodyText.trim().split('\n').slice(0,6).join(' | ').slice(0,600);
        forwardDebug('Detected likely error text in proxied page: ' + snippet, 'warn');
        sub.textContent = '‚ö†Ô∏è Remote page shows an error message (see Debug Logs). Overlay dismissed.';
        hideOverlay({error:'page-error-detected', snippet});
        return;
      }
    }

    // Repeated scanning (safe, non-blocking)
    let scannerInterval = null;
    function startScanner() {
      stopScanner();
      scannerInterval = setInterval(() => {
        try { scanIframeForProblems(); } catch(e){/* silent */ }
      }, 900);
    }
    function stopScanner(){ if (scannerInterval) { clearInterval(scannerInterval); scannerInterval = null; } }

    // When iframe loads successfully (onload fires), hide overlay
    iframe.addEventListener('load', () => {
      forwardDebug('‚úÖ Iframe loaded successfully.');
      // small delay to allow the in-page scripts to run before we remove overlay
      setTimeout(() => {
        try {
          // ensure not hiding right away if page is still clearly an error (scan)
          scanIframeForProblems();
          hideOverlay({on:'iframe.load'});
        } catch(e){
          hideOverlay({on:'iframe.load', err:e.message});
        }
      }, 650);
      stopScanner();
      stopTimer();
    });

    iframe.addEventListener('error', () => {
      forwardDebug('Iframe error event fired', 'error');
      sub.textContent = '‚ö†Ô∏è Iframe failed to load.';
      hideOverlay({on:'iframe.error'});
      stopScanner();
      stopTimer();
    });

    // Start the visual timer and scanner when the proxy page itself initializes
    (function init() {
      startTimer();
      startScanner();

      // auto-read hash to set iframe src if the proxy was opened directly with #url=...
      try {
        const params = new URLSearchParams(window.location.hash.replace(/^#/, ''));
        const target = params.get('url');
        if (target) {
          // if the client-proxy.js will also set content via postMessage/doc.write, this iframe src will be inert.
          // Setting src only if not set by outer script.
          if (!iframe.src || iframe.src === 'about:blank') {
            iframe.src = target;
            forwardDebug('Auto-set iframe src from hash: ' + target);
          }
        }
      } catch (e) {
        // ignore malformed hash
      }
    })();

    // cleanup when page is unloaded
    window.addEventListener('beforeunload', () => {
      stopTimer();
      stopScanner();
    });

    // expose a small API for client-proxy.js (if it wants to call)
    window.clientProxyOverlay = {
      hide: hideOverlay,
      debug: forwardDebug
    };
  </script>
</body>
</html>